# Uniswap global values across all exchanges
type Uniswap @entity {
    id: ID!
    # Inclusive of V1 and V2 Exchanges
    totalExchangeCount: Int!
    exchanges: [Exchange!]!
    
    # Inclusive of V1 and V2 Exchanges
    totalVolumeETH: BigDecimal!
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityETH: BigDecimal!
    totalLiquidityUSD: BigDecimal!          # Current value of liquidity in USD

    # Inclusive of V1 and V2 Exchanges
    totalTokenSells: BigInt!
    totalTokenBuys: BigInt!
    totalAddLiquidity: BigInt!
    totalRemoveLiquidity: BigInt!
    totalSwaps: BigInt!                
    totalMints: BigInt!
    totalBurns: BigInt!           
    totalSyncs: BigInt!   

    # TODO - determine whether to add swaps, mints, burns, and syncs array

    # TODO - determine if still needed
    exchangeHistoryEntityCount: BigInt!     # Count of all historical entities for exchanges - used for unique ids
    uniswapHistoryEntityCount: BigInt!      # Count of all historical entities for Uniswap - used for unique ids
    tokenHistoryEntityCount: BigInt!      
    reserveEntityCount: BigInt!

    # Inclusive of V1 and V2 Exchanges
    txCount: BigInt!

    # as reference for new day datas 
    mostLiquidTokens: [TokenDayData!]!
}

# Accumulated statistics from V1 and V2 Uniswap
type UniswapFactory @entity {
  id: ID!
  version: Int! # specify whether this is the V1 or V2 factory contract
  address: Bytes # current factory address for this version of Uniswap

  # exchange info 
  exchangeCount: Int!
  exchanges: [Exchange]!

  # total volume 
  totalVolumeUSD: BigDecimal!             
  totalVolumeETH: BigDecimal!

  # total liquidity
  totalLiquidityUSD: BigDecimal! 
  totalLiquidityETH: BigDecimal!
           
  # counters for ids               
  exchangeHistoryEntityCount: BigInt!     
  uniswapHistoryEntityCount: BigInt!    
  tokenHistoryEntityCount: BigInt!      
  reserveEntityCount: BigInt!
  totalTokenSells: BigInt!
  totalTokenBuys: BigInt!
  totalAddLiquidity: BigInt!
  totalRemoveLiquidity: BigInt!
  mintCount: BigInt! 
  burnCount: BigInt!
  swapCount: BigInt!
  syncCount: BigInt!
  txCount: BigInt!     

  # TODO - determine whether to add swaps, mints, burns, and syncs array

  # as reference for new day datas 
  mostLiquidTokens: [TokenDayData!]!                   
}

type Asset @entity {
    id: ID!
    isToken: Boolean!
    symbol: String                     
    name: String                       
    decimals: Int
    address: Bytes

    # derived prices
    derivedETH: BigDecimal # eth per token

    # token specific volume
    tradeVolumeToken: BigDecimal!
    tradeVolumeETH: BigDecimal!
    tradeVolumeUSD: BigDecimal!   

    # liquidity across all pairs 
    totalLiquidityToken: BigDecimal!          
    totalLiquidityETH: BigDecimal!  

    # address of weth exchange if exists 
    wethExchange: Bytes

    # all exchanges an asset is part of
    allExchanges: [Exchange!]
}

type Exchange @entity {
    id: ID!                                 # Uniswap Exchange address
    version: Int!                           # V1 or V2
    base: Asset!                            # ETH for V1 exchanges, token0 for V2 exchanges
    baseBalance: BigDecimal!                # ETH balance for V1 exchanges, token0 balance for V2 exchanges
    baseLiquidity: BigDecimal!              # Equals the base liquidity provided. Will likely be different than baseBalance
    target: Asset!                          # token for V1 Exchanges, token1 for V2 exchanges
    targetBalance: BigDecimal!              # token balance for V1 Exchanges, token1 balance for V2 exchanges
    targetLiquidity: BigDecimal!            # Equals the target token liquidity provided. Will likely be different thatn targetBalance
    # TODO - determine how to structure fees in schema to work for V1 and V2 fee structure
    fee: BigDecimal!                        # Always 0.3% for v1 uniswap
    startTime: Int!                         # Time exchange was created
    
    # TODO - determine if this is still needed
    ethBalance: BigDecimal!                 # Equals the ether balance of the contract

    combinedBalanceETH: BigDecimal!       # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
    combinedBalanceUSD: BigDecimal!       # Equal to combinedBalanceInUSD * DAI/ETH
    
    # TODO - determine if this is still needed with new way of tracking pool ownership
    totalUniToken: BigDecimal!              # Count of the underlying unitokens that represent liquidity provided ownership

    # Counting Events
    buyTokenCount: BigInt!
    sellTokenCount: BigInt!
    addLiquidityCount: BigInt!
    removeLiquidityCount: BigInt!
    mintCount: BigInt!              
    burnCount: BigInt!           
    swapCount: BigInt!                
    syncCount: BigInt!                  

    # Price in terms of the asset pair
    basePrice: BigDecimal!
    targetPrice: BigDecimal!

    # Price values using eth
    lastPrice: BigDecimal!                  # The last trade price
    price: BigDecimal!                      # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100
    tradeVolumeBase: BigDecimal!            # Total base traded EVER
    tradeVolumeTarget: BigDecimal!          # Total target traded EVER
    tradeVolumeETH: BigDecimal!             # Total eth traded EVER
    tradeVolumeUSD: BigDecimal!             # Total USD traded EVER, accumulated at each trade with current token usd price * amount
    totalValue: BigDecimal!                 # totalValue is accumulation of trade price * trade volume. i.e. TV = tokensSold * priceTokensSold
    weightedAvgPrice: BigDecimal!           # Avg price of all trades since inception. WAP = totalValue / totalVolume

    totalTxsCount: BigInt!                  # Total tx count EVER

    # Price values uing usd
    lastPriceUSD: BigDecimal!               # The last trade price in USD
    priceUSD: BigDecimal!                   # USD / token
    weightedAvgPriceUSD: BigDecimal!        # weightAvgPriceUSD = ( $1 of ETH in ETH ) / weightedAvgPrice

    # Fields used to help derived relationship
    factory: UniswapFactory! @derivedFrom(field: "exchanges")
    totals: Uniswap! @derivedFrom(field: "exchanges")
    tokenHolders: [UserExchangeData!]       # Relationship to show all token holders on the exchange
    liquidityPositions: [LiquidityPosition!] @derivedFrom(field: "exchange")
    liquidityTokenTransfers: [LiquidityTokenTransfer!] @derivedFrom(field: "exchange")
}

type User @entity {
    id: ID!                         # user eth adddress
    exchangeBalances: [UserExchangeData!]!  @derivedFrom(field: "user")
    liquidityPositions: [LiquidityPosition!] @derivedFrom(field: "user")
    liquidityTokenTransfersOut: [LiquidityTokenTransfer!] @derivedFrom(field: "fromUser")
    liquidityTokenTransfersIn: [LiquidityTokenTransfer!] @derivedFrom(field: "toUser")
}

type LiquidityPosition @entity {
  id: ID!
  user: User!
  liquidityTokenBalance: BigInt!
  exchange: Exchange!
  exchangeLiquidityTokenSupply: BigInt
  poolOwnership: BigDecimal
  valueInToken0: BigDecimal
  valueInToken1: BigDecimal
  totalValueInEth: BigDecimal
}

type LiquidityTokenTransfer @entity {
  id: ID! # concat: exchange-transactionHash-fromUser-toUser
  amount: BigInt!
  exchange: Exchange!
  transferType: String # Mint, Burn, or Transfer
  exchangeLiquidityTokenSupplyBefore: BigInt
  exchangeLiquidityTokenSupplyAfter: BigInt
  fromUserLiquidityTokenBalanceBefore: BigInt
  fromUserLiquidityTokenBalanceAfter: BigInt
  fromUserPoolOwnershipBefore: BigDecimal
  fromUserPoolOwnershipAfter: BigDecimal
  toUserLiquidityTokenBalanceBefore: BigInt
  toUserLiquidityTokenBalanceAfter: BigInt
  toUserPoolOwnershipBefore: BigDecimal
  toUserPoolOwnershipAfter: BigDecimal
  exchangeTotalEthLiquidityBefore: BigInt
  exchangeTotalEthLiquidityAfter: BigInt
  exchangeTotalTokenLiquidityBefore: BigInt
  exchangeTotalTokenLiquidityAfter: BigInt
  timestamp: BigInt!
  transaction: Transaction!
  fromUser: User!
  toUser: User!
}

type Migration @entity {
    id: ID!
    transaction: Transaction!
}

# trading and liquidity data around a user and their activity on a given exchange 
type UserExchangeData @entity {
    id: ID!                         # ID is concatenation of token and user addr. i.e. 0xahiow4-0xkashkd34....
    userAddress: Bytes!
    user: User!
    exchange: Exchange!

    # Liquidity Provider Data
    ethDeposited: BigDecimal!       # where negative means eth was exchanged for tokens
    tokensDeposited: BigDecimal!    # Where negative means tokens were exchanged for eth
    ethWithdrawn: BigDecimal!
    tokensWithdrawn: BigDecimal!
    uniTokenBalance: BigDecimal!

    # Trading Data
    # Note - Fee is always charged in what the user is paying with. i.e. you buy eth by paying in token. Fee is in token
    # Note - ethBought, ethSold, tokensBought, and tokensSold are effected by a basic Transfer
    ethBought: BigDecimal!
    ethSold: BigDecimal!
    tokensBought: BigDecimal!
    tokensSold: BigDecimal!
    ethFeesPaid: BigDecimal!
    tokenFeesPaid: BigDecimal!
    ethFeesInUSD: BigDecimal!
    tokenFeesInUSD: BigDecimal!
}

enum EventType {
    AddLiquidity,
    RemoveLiquidity,
    TokenPurchase,
    EthPurchase
}

type Transaction @entity {
    id: ID!  # txn  hash concatenated with exchange - need this for token to token swaps
    isMigration: Boolean
    migration: Migration
    addLiquidityEvents: [AddLiquidityEvent!]
    removeLiquidityEvents: [RemoveLiquidityEvent!]
    tokenPurchaseEvents: [TokenPurchaseEvent!]
    ethPurchaseEvents: [EthPurchaseEvent!]
    mints: [Mint]!
    burns: [Burn]! 
    swaps: [Swap]!
    syncs: [Sync]!
    block: Int!
    timestamp: Int!
    user: Bytes!
    fee: BigDecimal!
}

interface TransactionEvent {
  id: ID!
  transaction: Transaction!
  ethAmount: BigDecimal!
  tokenAmount: BigDecimal!
}

# Note - No fee to provide liqidity
type AddLiquidityEvent implements TransactionEvent  @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction! @derivedFrom(field: "addLiquidityEvents")
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    uniTokensMinted: BigDecimal! 
}

# Note - No fee to provide liqidity
type RemoveLiquidityEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction! @derivedFrom(field: "removeLiquidityEvents")
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    uniTokensBurned: BigDecimal! 
}

type TokenPurchaseEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction! @derivedFrom(field: "tokenPurchaseEvents")
    # Monetary Values. Positive or negative determined by the TradeType
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    tokenFee: BigDecimal!
    ethFee: BigDecimal!
}

type EthPurchaseEvent implements TransactionEvent @entity {
    id: ID!                 # Incrementing ID, 1, 2, etc, as txhashes can contain multiple events
    transaction: Transaction! @derivedFrom(field: "ethPurchaseEvents")
    # Monetary Values. Positive or negative determined by the TradeType
    ethAmount: BigDecimal!
    tokenAmount: BigDecimal!
    tokenFee: BigDecimal!
    ethFee: BigDecimal!
}

interface exchangeEvent {
  id: ID!
}

type Mint implements exchangeEvent @entity{
  id: ID!
  timestamp: Int!
  exchange: Exchange
  base: Asset
  target: Asset
  valueUSD: BigDecimal
  valueETH: BigDecimal
  amountBase: BigDecimal
  amountTarget: BigDecimal
  tx: Transaction!  @derivedFrom(field: "mints")
  logIndex: BigInt!
  feeTo: Bytes
  feeLiquidity: BigDecimal
  to: Bytes!
  liquidity: BigDecimal!
  reservesPre: Reserve
  reservesPost: Reserve
  sender: Bytes 
}

type Burn @entity{
  id: ID!
  exchange: Exchange
  timestamp: Int!
  base: Asset
  target: Asset
  valueUSD: BigDecimal
  valueETH: BigDecimal
  amountBase: BigDecimal
  amountTarget: BigDecimal
  tx: Transaction!  @derivedFrom(field: "burns")
  logIndex: BigInt!
  feeTo: Bytes
  feeLiquidity: BigDecimal
  from: Bytes
  liquidity: BigDecimal!
  reservesPre: Reserve
  reservesPost: Reserve
  sender: Bytes 
}

type Swap @entity{
  id: ID!
  exchange: Exchange
  timestamp: Int!
  tx: Transaction!  @derivedFrom(field: "swaps")
  tokenBought: Asset!
  amountBought: BigDecimal
  tokenSold: Asset!
  amountSold: BigDecimal
  valueUSD: BigDecimal
  valueETH: BigDecimal
  logIndex: BigInt!
  to: Bytes!
  sender: Bytes
}

type Sync @entity{
  id: ID!
  tx: Transaction!  @derivedFrom(field: "syncs")
  exchange: Exchange
  reservesPre: Reserve
  reservesPost: Reserve
}

##### Below are entites specifically for uniswap historical data #####

# Historical data for each event of each exchange. Useful for creating graphs and data analysis
type ExchangeHistoricalData @entity {
    id: ID!
    exchangeAddress: Bytes!
    type: EventType!
    timestamp: Int!

    ethLiquidity: BigDecimal!               # Equals the liquidty provided. Will likely be different than ethBalance
    tokenLiquidity: BigDecimal!             # Equals the token liquidity provided. Will likely be different thatn tokenBalance
    ethBalance: BigDecimal!                 # Equals the ether balance of the contract
    tokenBalance: BigDecimal!               # Equals the token balance of the contract
    combinedBalanceInEth: BigDecimal!       # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
    combinedBalanceInUSD: BigDecimal!       # Equal to combinedBalanceInUSD * DAI/ETH.  USD price at time of transaction
    totalUniToken: BigDecimal!              # Count of the unilying unitokens that represent liquidity provided ownership

    tokenPriceUSD: BigDecimal!              # USD / token. USD price at time of transaction
    price: BigDecimal!                      # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100

    tradeVolumeToken: BigDecimal!           # Total tokens traded EVER. i.e. cumulative
    tradeVolumeEth: BigDecimal!             # Total eth traded EVER. i.e. cumulative
    tradeVolumeUSD: BigDecimal!             # Total USD traded EVER - cumulative with price at time of trade

    totalTxsCount: BigInt!                  # Total tx count EVER
    feeInEth: BigDecimal!
}

# Data accumulated and condensed into day stats for each exchange
type ExchangeDayData @entity {
    id: ID!                                 # token address concatenated with unix date (Nov 2nd 2018 is 17837)
    date: Int!                              # starts on 1541116800 (Nov 2nd 2018 00:00:00). all dates must start on 00:00:00
    exchangeAddress: Bytes!
    ethBalance: BigDecimal!                 # Eth balance at last event within the day
    tokenBalance: BigDecimal!               # Token balance at last event within the day
    marginalEthRate: BigDecimal!            # tokenBalance / ethBalance
    ethVolume: BigDecimal!                  # Cumulative volume throughout the day
    tokenPriceUSD: BigDecimal!              # USD token price at last event within the day
    totalEvents: BigInt!                    
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
    id: ID! # timestamp rounded to current day by dividing by 86400 - should only be one per day
    date: Int!

    dailyVolumeInETH: BigDecimal!
    dailyVolumeInUSD: BigDecimal!

    totalVolumeETH: BigDecimal!           # volume just on eth -i.e. we dont double count volume
    totalLiquidityETH: BigDecimal!        # 2 * SUM(exchanges.ethLiquidity). Since tokenLiquiduity = ethLiquidity value, can just *2
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityUSD: BigDecimal!

    totalTokenSells: BigInt!                # Total events where tokens have been sold
    totalTokenBuys: BigInt!                 # Total events where tokens have been bought
    totalAddLiquidity: BigInt!              # Total events where liqidity has been added
    totalRemoveLiquidity: BigInt!           # Total events where liquidity have been removed

    txCount: BigInt!
}

# Data checkpointed at each timestamp for 24hour data
type UniswapHistoricalData @entity {
    id: ID!  # unique based on incremental entity count, one for each transactions
    timestamp: Int!

    totalVolumeETH: BigDecimal!           # volume just on eth -i.e. we dont double count volume
    totalLiquidityETH: BigDecimal!        # 2 * SUM(exchanges.ethLiquidity). Since tokenLiquiduity = ethLiquidity value, can just *2
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityUSD: BigDecimal!

    totalTokenSells: BigInt!                # Total events where tokens have been sold
    totalTokenBuys: BigInt!                 # Total events where tokens have been bought
    totalAddLiquidity: BigInt!              # Total events where liqidity has been added
    totalRemoveLiquidity: BigInt!           # Total events where liquidity have been removed

    txCount: BigInt!
}

type TokenDayData @entity {
  id: ID!                              
  date: Int!                           
  token: Asset!     

  # volume state 
  dailyVolumeToken: BigDecimal!   
  dailyVolumeETH: BigDecimal!               
  dailyVolumeUSD: BigDecimal! 

  # liquidity stats
  totalLiquidityToken: BigDecimal!
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!

  dailyTxns: BigInt! 

  # top pairs that this token is in by liquidity
  maxStored: Int!
  mostLiquidPairs: [ExchangeDayData!]!
}

type Reserve @entity{
  id: ID!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
}